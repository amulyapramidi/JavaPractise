##################################################
Spring Core 
##################################################
1. Two ways to read Bean configuration file - beans.xml 
a) ApplicationContext 
->This is used in latest spring apps.
->Functionality is similar to BeanFactory and some additional features. 
->This has pre-loading enabled by default means that beans get created in spring container(pre-loaded) even though they are not requested in program. This can be changed by adding the value in
'default-lazy-init=true' in beans.xml.
b) BeanFactory
->Used in beginning versions on spring. 
->Now exists only for backward compatability
->This doesn't have preloading enabled by default. Behaviour can be altered using 'deafult-lazy-init=true/false' in beans.xml
BeanScope :
~~~~~~~~~~~
Popular bean scopes : (There are others also)
a) Singleton (default scope)- Creates only one bean per spring container - When u request bean multiple times from context same bean object is returned
Lifecycle methods(init,destroy) of bean is managed by spring container
b) Prototype - Creates new bean everytime bean is requested.
Lifecycle method destroy of bean is not managed by spring container.
#### More from spring documentation ####
Although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of 'prototypes', configured destruction lifecycle callbacks are not called.
#########################################
2. In bean, list dependency can also be injected
3. A bean can be inserted in another bean using auto-wire
4. There are different types of Auto-Wiring- byType and byName
5. byName needs match of setter variable name
6. If the nested bean name is modified - need to regenerate setter again
7. To auto-wire a bean there are 2 days
a) Using <property name="Laptop" ref="bean_name">
b) Mentioning auto-wire="byType/byName" in parent bean node.
8. Type of list supported by spring is java.util.List
9. Have to findout why just mentioning annotation like @Autowired and @Component didn't work.
Annotaion Scan :
~~~~~~~~~~~~~~~

10. For annotations to be scanned, following in beans.xml
 		<context:component-scan base-package="com.amulya.spring" />
 		This requires xmlns differences so old beans.xml won't work directly.
11. When using annotations, beanName is to be used in lowerCase
Bean : Vendor
To request bean : 
Vendor obj = (Vendor) context.getBean("vendor"); // lower case when using beans with annotation
12. Bean should have '@Component' annotation and for Autowiring add '@Autowired'

Spring is nothing new. J2EE already provides similar functionality. Spring is a framework making use of J2EE componenets to make webdevelopment easier for developer.
Previously struts was there but it was only helping user with web components, spring helps users with all components of Application development - DB connectivity, making testing easier,
enabling easier way of implementing MVC, helping in business log etc.
Application Classes-> Spring Classes -> J2EE components
Spring is lightweight. Following are aspects of spring architecture.
1. Spring core
2. Spring AOP
3. Spring MVC
4. Spring Web
5. Spring ORM
6. Spring Context
7. Spring DAO
All the above components are loosely coupled, meaning if user wants to use only Spring MVC he doesn't need to learn other aspects.This is what light weight means.
A bean can be given init and destroy methods(need to mentioned in beans.xml)
RegisterShutDownhook can be called on ApplicationContext -> This will destroy all beans after end of main method
There are 3 ways of writing init and destroy for beans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Write methods in bean class-> mention their name in bean.xml
2. Annotate the methods with @PostConstruct, @PreDestroy and mention an annotation scnanner(CommonAnnotationBeanPostProcessor) bean in bean.xml
3. Implement 2 spring interfaces IntializingBean,DisposableBean
## When scope of bean is Prototype - Destroy method is not called on bean - User needs to manage destroy of bean.
Writing pre-init and post-init methods for bean [Common to all beans]:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. pre-init and post-init functionality using BeanPostProcessor-> implement this and mention beanPostprocessor name in beans.xml
## Even when I implemented this BeanPostProcessor - didn't get error that methods(postProcessBeforeInitialization, postProcessAfterInitialization) 
are to be implemented - In Spring 5.1.x those methods are @Nullable in jar so not mandatory to implement -_-
Bean and BeanName are the argument - bean data can be modified here.
-> For annotation way just add @Component on this class
2. If you have multiple beanpostprocessor classes, also implement Ordered interface and return desired order number in getOrder method
@Order(int) - annotation way - Not working :(
Want to modify bean property before bean creation:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Impement BeanFactoryPostProcessor and do needful in postProcessesBeanFactory method and mention the bean in beans.xml
2. Spring provides builtIn implementations of BeanFactoryPostProcessor, like PropertyPlaceHolderConfigurator
	To use this :
	~~~~~~~~~~~~
	In beans.xml we can provide placeholder like ${WelcomeNote}... created spring.properties and mention key-value pair there.. Also mention PropertyPlaceHolderConfigurator bean
	and also classpath to properties file
	# This is very useful as this enabled user to change bean data using property files, Different files for PROD,UAT etc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BeanPostProcessor VS BeanFactoryPostProcessor 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BeanPostProcessor [Bean Level] - Called when container initialises 'every bean'
BeanFactoryPostProcessor [Application Level] - Called during startup of the Spring context after all bean definitions will have been loaded but beans are yet to be 'initialised'.This allows for overriding or adding properties even to eager-initializing beans
-> When a bean is modified in both BPP and BFPP -> BFPP is the one that is given priorit, infact BPP is not called for that bean.
#########################################################################################
Spring MVC:
##########################################################################################

Model - Data 
View - UI Response
Controller - Handler of request

Following is the work flow for a request:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Request<------->[Front Controller]
				<-----------> [Handler Mapping]
				<-----------> [Controller]
				<-----------> [View Resolver]
				<-----------> [View]
[Handler Mapping] -> Based on URL guides front controller on which controller to called
[Controller] -> Creates Model object and name of view to used to display
[View Resolver] -> Guides Front Controller in resolving info related to View
[View] -> A JSP page that has gift-wrapped the data(model) sent by controller.
[Front Controller] -> This is DispatcherServlet that returns a View to user upon getting request

Steps to create Sample Spring MVC Application:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Mention Dispatcherservlet for '/' in web.xml
#####################
WITHOUT ANNOTATIONS
####################
1. Create controller class extending AbstractController that returns a ModelAndView object
2. Create view page Hello.jsp
3. Create file spring-dispatcher-servlet.xml 
	-> Mention bean for HandlerMapping - BeanNameUrlHandlerMapping 
	-> Mention controller bean with url pattern as name
	-> Mention ViewResolver bean (InternalViewResolver)- This contains prefix(/Web-INF/jsp),suffix(.jsp) for view 
#################
WITH ANNOTATIONS
#################
1. Create controller class returns a method that returns ModelAndView object. Add @Controller annotation and for method @RequestMapping("/Welcome")
2. Create view page Hello.jsp
3. Create file spring-dispatcher-servlet.xml 
	-> Mention ViewResolver bean (InternalViewResolver)- This contains prefix(/Web-INF/jsp),suffix(.jsp) for view 
	-> Mention component-scan node for Scanning of annotations
	<context:component-scan base-package="com.amulya.spring" />
	
MultiActionControllerClass: 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If a controller has more than 1 requestmapping

Controller :
@Controller
@RequestMapping("/greet")

Method : 
@RequestMapping("/Welcome")
User : <hostName>/<WebAppName>/greet/Welcome

Something in URL changes everytime
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@RequestMapping("/greet/Welcome/{username}")

Want to access a placeholder for URL 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Add argument : (@PathVariable("username") String name)
Usage : System.out.println("Hello "+name)

MultiplePathVariables ????
~~~~~~~~~~~~~~~~~~~~~~~~~~
Add argument : (@PathVariable Map<String,String> pathVars)
Spring-dispatcher-servlet.xml : Mention <mvc:annotation-driven/>
Usage : System.out.println("Hello "+pathVars.get("username")+" from "+pathVars.get("countryname"))
Want to handle POST requests :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@RequestMapping(Value="/Welcome" method=RequestMethod.POST)

Want to read variables in request :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-> Assume case where html page is using action as "POST" and has 2 text fields
In argument : @RequestParam("username") String name
-> Want to assign default value to variables in request
In argument : 	@RequestParam(value="username" defaultValue="DummyUser") String username
-> Have multiple requestParams ?
In argument : @RequestParam Map<String,String> requestVars

Code to createModelAndView object:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In Controller :
ModelAndView object = new ModelAndView(<ViewName>);
object.setObject("WelcomeMessage","Hello Welcome");
return object;
In <ViewName>.jsp
<h1>${WelcomeMessage}</h1>

Want to include a bean in the View :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In Controller :
Student student = new Student();
student.setName("NewUser");
ModelAndView object = new ModelAndView(<ViewName>)
object.setObject("student",student);
In View :
<h1>${student.name}</h1>

Usage of @ModelAttribute :
~~~~~~~~~~~~~~~~~~~~~~~~~~~
In this approach, spring creates a bean with request params as ModelAttribute. Attributes of bean must have same name as requestParams
In Method Argument :
@ModelAttribute("student") Student student
In Controller :
ModelAndView object = new ModelAndView(<ViewName>)
object.setObject("hello","sfkjffds");
-> No need to set modelattribute manually to ModelAndView object
View :
<h1>${student.name}</h1>
This approach of ModelAttribute to set data to beans, reduces additional server code where user has to create bean and set each requestparam
manually in controller method
Will this attribute work for other datatypes like String, List on the bean?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Yes.String,Long,Date,ArrayList<String> were used in one of the exampl. Conversion from String to datatypes mentioned in Bean is done by
spring during created of this attribute. This reduces a lot of java code for conversion, error handling for types
When common attributes are to be added in Each ModelAndView object :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In controller:

@ModelAttribute
public void addCommonObjectToAllViewsOfController(Model model)
{
model.add("watermark","All rights to this page are reserved")


}
-> This method gets called before RequestMapping gets resolved, all views will have access to this object now.
