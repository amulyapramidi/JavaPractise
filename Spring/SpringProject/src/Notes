##################################################
Spring Core 
##################################################
1. Two ways to read Bean configuration file - beans.xml 
a) ApplicationContext 
->This is used in latest spring apps.
->Functionality is similar to BeanFactory and some additional features. 
->This has pre-loading enabled by default means that beans get created in spring container(pre-loaded) even though they are not requested in program. This can be changed by adding the value in
'default-lazy-init=true' in beans.xml.
b) BeanFactory
->Used in beginning versions on spring. 
->Now exists only for backward compatability
->This doesn't have preloading enabled by default. Behaviour can be altered using 'deafult-lazy-init=true/false' in beans.xml
BeanScope :
~~~~~~~~~~~
Popular bean scopes : (There are others also)
a) Singleton (default scope)- Creates only one bean per spring container - When u request bean multiple times from context same bean object is returned
Lifecycle methods(init,destroy) of bean is managed by spring container
b) Prototype - Creates new bean everytime bean is requested.
Lifecycle method destroy of bean is not managed by spring container.
#### More from spring documentation ####
Although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of 'prototypes', configured destruction lifecycle callbacks are not called.
#########################################
2. In bean, list dependency can also be injected
3. A bean can be inserted in another bean using auto-wire
4. There are different types of Auto-Wiring- byType and byName
5. byName needs match of setter variable name
6. If the nested bean name is modified - need to regenerate setter again
7. To auto-wire a bean there are 2 days
a) Using <property name="Laptop" ref="bean_name">
b) Mentioning auto-wire="byType/byName" in parent bean node.
8. Type of list supported by spring is java.util.List
9. Have to findout why just mentioning annotation like @Autowired and @Component didn't work.
Annotaion Scan :
~~~~~~~~~~~~~~~

10. For annotations to be scanned, following in beans.xml
 		<context:component-scan base-package="com.amulya.spring" />
 		This requires xmlns differences so old beans.xml won't work directly.
11. When using annotations, beanName is to be used in lowerCase
Bean : Vendor
To request bean : 
Vendor obj = (Vendor) context.getBean("vendor"); // lower case when using beans with annotation
12. Bean should have '@Component' annotation and for Autowiring add '@Autowired'

Spring is nothing new. J2EE already provides similar functionality. Spring is a framework making use of J2EE componenets to make webdevelopment easier for developer.
Previously struts was there but it was only helping user with web components, spring helps users with all components of Application development - DB connectivity, making testing easier,
enabling easier way of implementing MVC, helping in business log etc.
Application Classes-> Spring Classes -> J2EE components
Spring is lightweight. Following are aspects of spring architecture.
1. Spring core
2. Spring AOP
3. Spring MVC
4. Spring Web
5. Spring ORM
6. Spring Context
7. Spring DAO
All the above components are loosely coupled, meaning if user wants to use only Spring MVC he doesn't need to learn other aspects.This is what light weight means.
A bean can be given init and destroy methods(need to mentioned in beans.xml)
RegisterShutDownhook can be called on ApplicationContext -> This will destroy all beans after end of main method
There are 3 ways of writing init and destroy for beans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Write methods in bean class-> mention their name in bean.xml
2. Annotate the methods with @PostConstruct, @PreDestroy and mention an annotation scnanner(CommonAnnotationBeanPostProcessor) bean in bean.xml
3. Implement 2 spring interfaces IntializingBean,DisposableBean
## When scope of bean is Prototype - Destroy method is not called on bean - User needs to manage destroy of bean.
Writing pre-init and post-init methods for bean [Common to all beans]:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. pre-init and post-init functionality using BeanPostProcessor-> implement this and mention beanPostprocessor name in beans.xml
## Even when I implemented this BeanPostProcessor - didn't get error that methods(postProcessBeforeInitialization, postProcessAfterInitialization) 
are to be implemented - In Spring 5.1.x those methods are @Nullable in jar so not mandatory to implement -_-
Bean and BeanName are the argument - bean data can be modified here.
-> For annotation way just add @Component on this class
2. If you have multiple beanpostprocessor classes, also implement Ordered interface and return desired order number in getOrder method
@Order(int) - annotation way - Not working :(
Want to modify bean property before bean creation:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Impement BeanFactoryPostProcessor and do needful in postProcessesBeanFactory method and mention the bean in beans.xml
2. Spring provides builtIn implementations of BeanFactoryPostProcessor, like PropertyPlaceHolderConfigurator
	To use this :
	~~~~~~~~~~~~
	In beans.xml we can provide placeholder like ${WelcomeNote}... created spring.properties and mention key-value pair there.. Also mention PropertyPlaceHolderConfigurator bean
	and also classpath to properties file
	# This is very useful as this enabled user to change bean data using property files, Different files for PROD,UAT etc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BeanPostProcessor VS BeanFactoryPostProcessor 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BeanPostProcessor [Bean Level] - Called when container initialises 'every bean'
BeanFactoryPostProcessor [Application Level] - Called during startup of the Spring context after all bean definitions will have been loaded but beans are yet to be 'initialised'.This allows for overriding or adding properties even to eager-initializing beans
-> When a bean is modified in both BPP and BFPP -> BFPP is the one that is given priorit, infact BPP is not called for that bean.
#########################################################################################
Spring MVC:
##########################################################################################

Model - Data 
View - UI Response
Controller - Handler of request

Following is the work flow for a request:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Request<------->[Front Controller]
				<-----------> [Handler Mapping]
				<-----------> [Controller]
				<-----------> [View Resolver]
				<-----------> [View]
[Handler Mapping] -> Based on URL guides front controller on which controller to called
[Controller] -> Creates Model object and name of view to used to display
[View Resolver] -> Guides Front Controller in resolving info related to View
[View] -> A JSP page that has gift-wrapped the data(model) sent by controller.
[Front Controller] -> This is DispatcherServlet that returns a View to user upon getting request

Steps to create Sample Spring MVC Application:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Mention Dispatcherservlet for '/' in web.xml
#####################
WITHOUT ANNOTATIONS
####################
1. Create controller class extending AbstractController that returns a ModelAndView object
2. Create view page Hello.jsp
3. Create file spring-dispatcher-servlet.xml 
	-> Mention bean for HandlerMapping - BeanNameUrlHandlerMapping 
	-> Mention controller bean with url pattern as name
	-> Mention ViewResolver bean (InternalViewResolver)- This contains prefix(/Web-INF/jsp),suffix(.jsp) for view 
#################
WITH ANNOTATIONS
#################
1. Create controller class returns a method that returns ModelAndView object. Add @Controller annotation and for method @RequestMapping("/Welcome")
2. Create view page Hello.jsp
3. Create file spring-dispatcher-servlet.xml 
	-> Mention ViewResolver bean (InternalViewResolver)- This contains prefix(/Web-INF/jsp),suffix(.jsp) for view 
	-> Mention component-scan node for Scanning of annotations
	<context:component-scan base-package="com.amulya.spring" />
	
MultiActionControllerClass: 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If a controller has more than 1 requestmapping

Controller :
@Controller
@RequestMapping("/greet")

Method : 
@RequestMapping("/Welcome")
User : <hostName>/<WebAppName>/greet/Welcome

Something in URL changes everytime
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@RequestMapping("/greet/Welcome/{username}")

Want to access a placeholder for URL 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Add argument : (@PathVariable("username") String name)
Usage : System.out.println("Hello "+name)

MultiplePathVariables ????
~~~~~~~~~~~~~~~~~~~~~~~~~~
Add argument : (@PathVariable Map<String,String> pathVars)
Spring-dispatcher-servlet.xml : Mention <mvc:annotation-driven/>
Usage : System.out.println("Hello "+pathVars.get("username")+" from "+pathVars.get("countryname"))
Want to handle POST requests :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@RequestMapping(Value="/Welcome" method=RequestMethod.POST)

Want to read variables in request :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-> Assume case where html page is using action as "POST" and has 2 text fields
In argument : @RequestParam("username") String name
-> Want to assign default value to variables in request
In argument : 	@RequestParam(value="username" defaultValue="DummyUser") String username
-> Have multiple requestParams ?
In argument : @RequestParam Map<String,String> requestVars

Code to createModelAndView object:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In Controller :
ModelAndView object = new ModelAndView(<ViewName>);
object.setObject("WelcomeMessage","Hello Welcome");
return object;
In <ViewName>.jsp
<h1>${WelcomeMessage}</h1>

Want to include a bean in the View :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In Controller :
Student student = new Student();
student.setName("NewUser");
ModelAndView object = new ModelAndView(<ViewName>)
object.setObject("student",student);
In View :
<h1>${student.name}</h1>

Usage of @ModelAttribute :
~~~~~~~~~~~~~~~~~~~~~~~~~~~
In this approach, spring creates a bean with request params as ModelAttribute. Attributes of bean must have same name as requestParams
In Input form :
<input type="text" name="name"></input>
In Method Argument :
@ModelAttribute("student") Student student
Inside method :
ModelAndView object = new ModelAndView(<ViewName>)
object.setObject("hello","sfkjffds");
View :
<h1>${student.name}</h1>

-> No need to set modelattribute manually to ModelAndView object

Note that the html elements name in input form must match with beans attribute name

What if my class has dependency on other class -> Will attributes be set even for composed class ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Yes. Say Student bean has Address bean inside it. 
In input form :
<input type="text" name="student.address.name"></input>
In Method Argument :
@ModelAttribute("student") Student student // Notice how student class is only used - no need to mention nested class
Inside method :
ModelAndView object = new ModelAndView(<ViewName>)
object.setObject("hello","sfkjffds");
View :
<h1>${student.address.name}</h1>

This approach of ModelAttribute to set data to beans, reduces additional server code where user has to create bean and set each requestparam
manually in controller method

Will this ModelAttribute work for other datatypes like String, List on the bean?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Yes.String,Long,Date,ArrayList<String> were used in one of the example. 
Conversion from String(form inputs are string) to respective datatypes in Bean is done by spring during creation of this attribute.
This reduces a lot of java code for conversion of Date objects/list from String to required datatype, error handling for types etc.
##################################################
What if databinding results in conversion error :
###################################################
If user enter String as input for a field that expects Long, Spring will throw 'Syntactical Error' while binding Input to bean.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Approach - 1 : Use Basic BindingResult
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Make use of 'BindingResult' to handle run-time errors - Navigate user to input form in case of wrong data
In Method Argument :
(@ModelAttribute("student") Student student, BindingResult result)
Inside method :
if(result.hasErrors())
{
ModelAndView object = new ModelAndView(<Input View>)
object.setObject("hello","sfkjffds");
}
In View : Also requires a TAG to be added in View
<form:errors path="student.*" />
Note that data is reset in case of error and user is redirected to same input form.
Problem : error message looks like Stack trace- Not easy for user to understand.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Approach - 2 : BindingResult with JSR
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This approach enables user to perform checks on bean attributes at the time of data binding using 'Annotations'.
Ask : Want to validate that empName should have min 10 characters and max 50.
~~~~~~~~~~~ JSR 303 ~~~~~~~~~~~
JSR[Java Specification Request] - 2 Spec (JSR 303/349) provided for Bean Validation by a community called JCP.
Apache Hibernate validator - Library that implements JSR 303. Used mostly for bean validations.
~~~~~~~~~~~~~
Usage :
Classpath : Include Hibernate validator jar.
Controller :
public ModelAndView getEmpFromSuccess(@Valid @ModelAttribute("emp") Employee emp, BindingResult result) throws Exception 
Bean :
@Size(min=10, max=50)
Note : @Valid is added in argument to enable validations.
String empName
NOTE : All these checks would have to done in java code if this was J2EE way. Spring has reduced server code needed for data validation.
Want to write my own error message instead of Hibernate size validation error ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In the above example change the annotation as 
@Size(min=10, max=50, message="Please enter correct data for Name i.e between {min} and {max}")


Want to move all such validation messages to a file ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~
Spring MessageSource
~~~~~~~~~~~~~~~~~~~~
In spring-dispatcher-servlet.xml, include following bean :

<bean id="MessageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
<property name="basename" value="<Value To porperty file>"/>
</bean>

In property file (CustomErrorMessages.properties)

Size.student1.studentName=please enter correct data for studentName b/w 2 and 30

NOTE : Following is the (priority) followed by spring while looking for custom error messages in the property file.

1. <Bean Validation Annotation>.<Reference Name>.<Attribute>  : Size.student1.studentName
2. <Bean Validation Annotation>.<Attribute> : Size.studentName
3. <Bean Validation Annotation>.<Attribute Type> : Size.java.lang.String
4. <Bean Validation Annotation> : Size

If such property is not found then default validation given by validator will be shown.

Dont want to hard-code some data in Custom error message?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Before : Size.student1.studentName=please enter correct data for studentName b/w 2 and 30
After : Size.student1.studentName=please enter correct data for {0} b/w {2} and {1}

NOTE : {0} - Attribute Name {2} - Min value {1} - Max value
{0} - Attribute Name that violates Validation
{1) and so on - Sorted order of validation attributes.

Dont want to restart server everytime I change properties file?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Add new property cacheSecongs in MessageSource bean: 

<bean id="MessageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
<property name="basename" value="<Value To porperty file>"/>
<property name="cacheSeconds" value="1"/>
</bean>
NOTE : This might effect performance.

Some more validation annotations :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. @Pattern(regexp="[^0-9]*")
Used to verify an attribute against regex say name field doesn't want numbers 
2. @Past
For Date attributes, if you want DOB to be earlier than today.
3. @Max(int)
Value should not exceed int provided. Say for age max allowed is 50. 
In Similar way @NotNull, @NotEmpty, @Future, @Min. etc

Want to write custom form validation annotations ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Create an interface with required AnnotationName, This interface needs annotations and one of them is 
@Constraint(validatedBy=HobbiesValidator.class)
2. In HobbiesValidator.java - extend CustomValidator and write desired validation
3. In bean mention new annotation for attribute '@isValidHobby'

Want to customise 'Custom form annotations' to take parameters ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ask : Want to provide a pre-defined list of hobbies to verify against @isValidHobby.

1. In interface, add variable String validListOfHobbies();
2. In bean update the annotation as @isValidHobby(listOfHobbies='Music|Dance|Painting')
3. In HobbiesValidator.java, in init(isValidHobby isvalidHobby), do isValidHobby.validListOfHobbies(); and assign it to local variable
and use in 'isValid' method to cross check.
4. To provide default set of hobbies incase user doesn't mention in annotation :

@isValidHobby(listOfHobbies='Music|Dance|Painting')
@isValidHobby()
For the above thing to work, in interface, update variable as : String validListOfHobbies default 'Music|Dance|Painting';


What if I want to omit a bean attribute from Data Binding ? :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ask : Don't bind studentDetails to Student bean even if controller method has student as @ModelAttribute
In Controller :
@InitBinder
public void initBinder(WebDataBinder binder)
{
binder.setDisallowedFields(new String[]{"studentDetails"})
}

What if I want to provide desired Date conversion format for a bean attribute while data binding :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In Controller :
@InitBinder
public void initBinder(WebDataBinder binder)
{
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy*****mm*****dd"); // Assume we want input provided in this format to be converted to date object
binder.registerCustomEditor(Date.class, "studentDOB", new CustomDateEditor(dateFormat,false));
}
Are there other Built-In Property Editors ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Yes.These are provided by Spring to customise Type Conversion during data binding based in desired way.
There are CustomFileEditor,CustomDateEditor, CustomNumberEditor,  CustomClassEditor and many more.

Custom Property Editor
~~~~~~~~~~~~~~~~~~~~~~

In case I want to write checks on input field and manipuate data before data binding.

Write class extending PropertyEditorSupport and in method 'setAsText' manipulate data as needed / write checks .
Eg. StudentNameEditor - This might check if studentName starts doesn't start with Mr/Ms append Ms to studentName.

In Controller :
@InitBinder
public void initBinder(WebDataBinder binder)
{
binder.registerCustomEditor(String.class, "studentName", new StudentNameEditor());
}
When common attributes are to be added in Each ModelAndView object :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In controller:

@ModelAttribute
public void addCommonObjectToAllViewsOfController(Model model)
{
model.add("watermark","All rights to this page are reserved")
}
-> This method gets called before RequestMapping gets resolved, all views will have access to this object now.

###################################################################
Interceptors -  Used to perform some task before request is handled
###################################################################

Ask : Would want my web page to work on all days except sunday. Sunday should give error that page is under maintainance.
Analysis: What is needed is to be able to decide whether request should be given to controller method or not.
How to do :

1. Write a class extending HandlerInterceptorAdapter and override method preHandle and write desired logic

@override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{
Calender cal = Calender.getInstance();
int dayOfWeek = cal.get(cal.DAY_OF_WEEK);
if(dayOfWeek==1) // Then its sunday
{
	response.getWriter().write("Website is closed today for maintainance");
	return false; // False would not forward request to controller and return response.
}
else
	return true;
}
2. Mention this bean in Spring-dispatcher-servlet.xml

<mvc-interceptors>
<bean class="<package.class>"/>
</mvc-interceptors>

HandlerInterceptorAdapter provides 3 methods :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. PreHandle - Called before request is delegated to handler 
2. PostHandle -  Called after handler method. (Before viewObject is resolved)
3. AfterCompletion - Called after viewobject is created

Order of events :
PreHandle()->Handler method called based on Request Mapping -> PostHandle() -> View page created (*.jsp)-> AfterCompletion()

Want interceptor to be applied only on a specific URL :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In Spring-dispatcher-servlet.xml, include 'mvc-interceptor' tags and 'mvc-mapping' tags

<mvc-interceptors>
	<mvc-interceptor>
		<mvc-mapping path="/hello.html"/>
		<bean class="<package.class>"/>
	</mvc-interceptor>
</mvc-interceptors>

##############################################################################
Internationalization - Based on language preference, UI labels should be shown
###############################################################################
i18n - Acronym for ‘internationalization’ (‘i’ + 18 letters + ‘n’; lower case i is used to distinguish it from the numeral 1 (one)).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Internationalization VS Locatization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Internationalization is the process of designing and building an application to facilitate localization. 
Localization, in turn, is the cultural and linguistic adaptation of an internationalized application to two or more culturally-distinct markets.

Internationalization prepares your application for localization

#################################################################
Approach - 1 : For i18n depending on Browser's language selection
#################################################################

Have already made use of MessageSource to bind data from property files. Same is used for Internationalization also.

In View hello.jsp :

Previous : 
~~~~~~~~~~~~~~~
<h1> Student Name : 

Now :
~~~~~~~~~~~~~~~
<h1> <spring:message code="label.name"/>

In spring-dispatcher-servlet.xml :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<bean id="MessageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
<property name="basename" value="<Path>/<propertyFileName>"/>
<property name="cacheSeconds" value="1"/>
</bean>
Under Properties folder, create 2 files <propertyFileName>_en.properties,<propertyFileName>_zh.properties with label.name=Student name in 2 different
languages.

#############################################################################
Approach - 2 : For i18n depending on user's language selection in Application
#############################################################################
This is for scenario where user is given option for langugae selection in applicaiton page itself.

1. In View.jsp - create 2 options like below :

<a href="/SpringSampleApp/View.html?siteLanguage=en">English</a>
<a href="/SpringSampleApp/View.html?siteLanguage=fr">French</a>

NOTE : Same page is requested with siteLanguage in queryParam.

2. Register LocaleChangeInterceptor bean 

In spring-dispatcher-servlet.xml include 2 beans :

<mvc-interceptors>
	<mvc-interceptor>
		<bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
      			<property name="paramName" value="siteLanguage" />
		</bean>
	</mvc-interceptor>
</mvc-interceptors>
3. Register CookieLocaleResolver bean
This is mandatory to include if using 'LocaleChangeInterceptor'. An alternative to this is 'SessionLocaleResolver'
~~~~~~~~~~~~~~~~~~~~
CookieLocaleResolver
~~~~~~~~~~~~~~~~~~~~
If this bean is mentioned then spring application will first check in client input if any cookie related to language preference/ locale is present.
Yes---Then that is considered.
No---Will check if bean has param 'defaultLocale', if 'defaultLocale' is not mentioned, then considers request header 'accept-header' for locale.
This header gets added by broswer in request params based on language preferences.

<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">
	<property name="defaultLocale" value="en" />
	<property name="cookieName" value="myLocalNameCookie"></beans:property>
	<property name="cookieMaxAge" value="3600"></beans:property>
</bean>

######################
Multiple Themes
######################

Scenario is when u want give choice to user on theme and based on that we need to switch style sheet.
1. In view.jsp - give 2 options to user


<a href="?theme=green">Green</a>
<a href="?theme=pink">Pink</a>

2. Mention ThemeChangeInterceptor in spring-dispatcher-servlet.xml

<mvc-interceptors>
	<mvc-interceptor>
		<bean id="themeChangeInterceptor" class="org.springframework.web.servlet.theme.ThemeChangeInterceptor">
			<property name="paramName" value="theme" />
		</bean>
	</mvc-interceptor>
</mvc-interceptors>

3. Mention CookieThemeResolver 

<bean id="themeResolver" class="org.springframework.web.servlet.theme.CookieThemeResolver">
		<property name="defaultThemeName" value="green" />
</bean>

4. Mention 'ResourceBundleThemeSource' to search for themes. Notice how MessageSource is not used for themes.

<bean id="themeSource"
		class="org.springframework.ui.context.support.ResourceBundleThemeSource">
			<property name="basenamePrefix" value="theme-" />
</bean>
5. In theme-green.properties
css=themes/green.css

##################################
Exception Handling 
##################################
Want to return a view page for Runtime Exception instead of default application server page.
1. Add a new view for error scenario.
DefaultErrorPage.jsp

<h1> Application has encountered exception . Click on <a href="/AppName/admissionForm.html">link</a> to redirect</h1>

2. In controller class :

@ExceptionHandler(value=Exception.class)
public String handleException(Exception e)
{
System.out.println("Inside generic exception handler");
return "DefaultErrorPage";
}
NOTE : This is generic exception handler. Can be customised to NullPointerException,IOException etc. 
This removes the need to add try Catch for every handler method.

##########################
Need for ControllerAdvice
#########################
Currently we are writing Expception handling for each controller. This would cause repitition of exception handler methods. @ControllerAdvice
provides a way to move all common exception handling logic under one class.
Create a class with @ControllerAdvice and move commmon ExceptionHandler methods there.
PROBLEM :
When Exceptionhndling is done this way, the statusCode in response is 200. This is wrong since request had a problem.
To give desired StatusCode, include @ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR).

@ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR)
@ExceptionHandler(value=Exception.class)
public String handleException(Exception e)
{
System.out.println("Inside generic exception handler");
return "DefaultErrorPage";
}

#################################################
Achieving ExceptionHandling without annotations :
#################################################

In spring-dispatcher-servlet.xml , mention :


<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <map>
	    	<entry key="IOException" value="error/IOException"/>
	    </map>
        </property>
        <property name="defaultErrorView" value="error/genericView"/>
	<property name="warnLogCategory" value="MVCLogger"/> // logger category (same as logger) needed to log all these exceptions handled
    </bean>

NOTE: Here value refers to viewNames.

####################
Web Service / API
####################
A web service is any piece of software that makes itself available over the internet. It exposes some of it's functionality to other applicaitons
(called Client Application) over internet. Client needs to have info related to functionality provided by Webservice like endpoint, operations etc,
this is made into a XML file known as WSDL file (Web Service Descrption Language).
To communicate to WebService a client Application can make use of 2 protocols : SOAP(Simple Object Access Protocol) or REST(Representation State Transfer).

RESTful Service : If a Web Service follows REST guidelines then it is called RESTful.
This is applied to a Client-Server environment
REST Guidelines :
~~~~~~~~~~~~~~~~~
1. Any data/functionality on server that client can access/modify is a 'Resource'. Any no. of resources can be present.
2. Response received by client is a 'Representation' or copy of resource in any of the formats - xml, json, file, pdf etc.
3. Response = Representation of Resource + Additional Information.
Additional Information - Meta data of response like size,format etc.
By analysing this info, client gets to know about response -  info needed to process response.
4. Any no. of intermediaries can be installed b/w server and client for load balancing, response caching, server security etc.
Eg. Firewall can be installed to filter requests. Response caching server can be installed.
5. Every request made by client must be independent of previous request.
6. REST is best realised using HTTP protocol.

############################
Creating basic REST JSON service
############################
1. In controller class, create method to handle URL '/REST/student' with RequestMethod as GET.Method must return ArrayList<Student>.
@ResponseBody
@RequestMapper(value="/REST/student", method=RequestMethod.GET)
public ArrayList<Student> getStudents()
{
	// creates student objects, adds them to arraylist and returns.
}
2. Notice that @ResponseBody is included- 3 jackson jars are also included in classpath. Whenever spring notices this annotation,it will
understand that View will not be returned and it checks if jackson jars are present and converts response to JSON.
3. Want to get specific student 

@ResponseBody
@RequestMapper(value="/REST/student/{studentName}", method=RequestMethod.GET)
public Student getStudents(@PathVariable("studentName") String studentName)
{
	// Matches studentName in DB and returns Student.
}
##################################################
REST JSON API Annotations : These are from jackson
###################################################
1. Want attribute names to be different in JSON response ?
In Student.java :

@JsonProperty("student_name") 
String studentName;

Same format must be following in request body (student_name instead of studentName) also.

2. Want to set specific order of attributes JSON response rather than Spring auto-sorting it ? 

In Student.java :

@JsonPropertyOrder({ "student_name", "studentDOB", "studentId" })
class Student{
// getters and setters
}
3. Want to ignore some attributes in JSON response ?
In Student.java :

@JsonIgnoreProperties({"studentDistrict"})
class Student{
// getters and setters
}
4. Don't want to include null attributes in response ?
In Student.java :

@JsonInclude(JsonInclude.Include.NON_EMPTY)
class Student{
// getters and setters
}

NOTE : For better usability, never mix and match methods in controller classes like methods that return ModelAndView and responsebody.
It's better to create seperate controllers, one for ModelAndView response and other for REST.

################
@RestController
################
Currently for each handler method in controller, we are adding annotations @ResponseBody, instead if the @Controller method is replaced
with @RestController then it means it is a @Controller with each method having @ResponeBody. This will be resovlved this way by Spring at run
time.

@RestController=@Controller+@ResponseBody for each method.

In the existing project, added jackson JSON jars for JSON response, in similar way if Jackson databind XML jar (& it's dependencies) are added
then the controller will respond in both XML and JSON depending on 'Accept' in request header.

########################################################
Produces - To specify response format of handler method
#########################################################

Want a handler method to respond in specific response format ?

@RequestMapping(produces = MediaType.APPLICATION_XML_VALUE)
public ArrayList<Student> getStudents()
{
// returns students list in XML format.
}

This will only support requests with 'Accept' as XML.

What if user requests for a different format ? If XML is mentioned in 'produces' and user provides JSON then it will throw exception with
error 'Could not find acceptable Representation'.

##############
@RequestBody
##############

-> For PUT request, want to access request body ?

URL : <hostname>/SpringAppName/student/bill
Body :
<student>
<studentAddress>UpdatedAddress</studentAddress>
</student>

@RequestMapping(value="/student/{name}", method=RequestMethod.PUT, produces = MediaType.APPLICATION_XML_VALUE)
public boolean updateStudent(@PathVariable("name") String studentName, @RequestBody Student student)
{
// check if student is present in DB with student name and update studentAddress(extracted from requestbody) and return update status
}
While making this request include 'Content-Type' in Request header.
NOTE : Spring performs conversion of data in Request body to java object Student and makes it available as Student specified in argument.
Notice how we haven't speicfied 'produces' so spring converts XML /JSON RequestBody to Student object depending on 'Content-Type' mentioned.
Notice how this conversion is similar to @ModelAttribute in ViewTechnology approach.

########################
Accept v/s Content-Type 
########################

Accept indicates what kind of response from the server the client can accept. This is generally specified by Client.
Content-type always is about the content of the current request or response. This can be added by either Client or Server.

########################################################
consumes - To specify request format of handler method
#########################################################

This will only support requests with 'Content-Type' as XML.

@RequestMapping(value="/student/{name}", method=RequestMethod.PUT, consumes = MediaType.APPLICATION_XML_VALUE)
public boolean updateStudent(@PathVariable("name") String studentName, @RequestBody Student student)
{
// check if student is present in DB with student name and update studentAddress(extracted from requestbody) and return update status
}

##################################################################################################
ResponseEntity - Use in scenarios where you want to manipulate headers and status code in response
##################################################################################################

ResponseEntity represents the whole HTTP response: status code, headers, and body. 
Because of it, we can use it to fully configure the HTTP response.

Consider a scenario where you want to manipulate response codes based on your exception handling :

@RequestMapping(value = "/age")
public ResponseEntity<String> age( @RequestParam("yearOfBirth") int yearOfBirth) {
  
    if (isInFuture(yearOfBirth)) {
        return new ResponseEntity<>("Year of birth cannot be in the future", HttpStatus.BAD_REQUEST);
    }
 
    return new ResponseEntity<String>("Your age is " + calculateAge(yearOfBirth),HttpStatus.OK);
}
Order of arguments : Data,header,StatusCode

ResponseEntity<T> Here T refers to type of Data only as Headers and StatusCode are not custom params.

Notice how argument of ResponseEntity is type of first argument and not StatusCode.
In case of setting only Status Code 

new ResponseEntity<void>(HttpStatus.OK);

Can also be writted using static methods as below :

Old : new ResponseEntity<String>("Your age is " + calculateAge(yearOfBirth),HttpStatus.OK);
New : ResponseEntity.accepted().header("Custom-Header", "foo").body("Your age is " + calculateAge(yearOfBirth));

POST : return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED); // This returns 201.
Generally POST request also adds Response Header 'location' that gives complete URL to access the newly created resource.
@RequestMapping(value="/students", method=RequestMethod.POST)
public ResponseEntity<Object> createStudent(@RequestBody Student student) {
	Student savedStudent = studentRepository.save(student);

	URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
			.buildAndExpand(savedStudent.getId()).toUri();
	return ResponseEntity.created(location).build();
}
location: http://localhost:8080/SpringApp/students/4
Argument mentioned under path is appened to current request URL and ID is replaced.
##############################
Want to test REST Services :
##############################

public static void getEmployees()
{
    final String uri = "http://localhost:8080/springrestexample/employees.xml";
     
    RestTemplate restTemplate = new RestTemplate();
    String result = restTemplate.getForObject(uri, String.class);
     
    System.out.println(result);
}
###################################
New annotaions from Spring MVC 4.3
###################################
@GetMapping("/student") : @RequestMapping(value="/student", method = RequestMethod.GET)
Similar for other annotations
@GetMapping supports the consumes attribute like  @RequestMapping.

######################
Variants of @Component
######################
There are variants of @Component in Spring Core.
@Component 
	<------> @Repository
	<------> @Service
	<------> @Controller
┌────────────┬─────────────────────────────────────────────────────┐
│ Annotation │ Meaning                                             │
├────────────┼─────────────────────────────────────────────────────┤
│ @Component │ generic stereotype for any Spring-managed component │
│ @Repository│ stereotype for persistence layer                    │
│ @Service   │ stereotype for service layer                        │
│ @Controller│ stereotype for presentation layer (spring-mvc)      │
└────────────┴─────────────────────────────────────────────────────┘

##############################
Content Negotiation in Spring
##############################
Generaly Spring MVC can return 2 types of data, XML/JSON or View.
There might be situations where we want both. This is called Content Negotiation.
Eg. http://localhost:1234/SpringMVC/student.xml , http://localhost:1234/SpringMVC/student.xls both should be resolved based on extension.
NOTE : Writing different @RequestMapping methods (one for "/student.xml" and one for "/student.xls")is not a solution as it causes code duplication and is not a neat way to do.

We returned different presentations for same content using jackson jars, produces and 'Accept' header. This is just half part of what we 
want to achieve now.

This can be achieved using ContentNegotiationViewResolver.

<bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver">
      <property name="order" value="1" />
      <property name="mediaTypes">
        <map>
        <entry key="xml" value="application/xml" />
        <entry key="json" value="application/json" />
        </map>
      </property> 
      <property name="defaultViews">
        <list>
          <!-- JSON View -->
          <bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView">
          </bean>
         </list>
      </property>
      <property name="ignoreAcceptHeader" value="true" />
</bean>


