##################################################
Spring Core 
##################################################
1. ApplicationContext is needed to load beans.xml
2. In bean, list dependency can also be injected
3. A bean and be inserted in another bean using auto-wire
4. There are different types of Auto-Wiring- byType and byName
5. byName needs match of setter variable name
6. If the nested bean name is modified - need to regenerate setter again
7. To auto-wire a bean there are 2 days
a) Using <property name="Laptop" ref="bean_name">
b) Mentioning auto-wire="byType/byName" in parent bean node.
8. Type of list supported by spring is java.util.List
9. Have to findout why just mentioning annotation like @Autowired and @Component didn't work.
Annotaion Scan :
~~~~~~~~~~~~~~~

10. For annotations to be scanned, following in beans.xml
 		<context:component-scan base-package="com.amulya.spring" />
 		This requires xmlns differences so old beans.xml won't work directly.
11. Following is line to remember 
By default, Spring will lower case the first character of the component – from ‘CustomerService’ to ‘customerService’.
And you can retrieve this component with name ‘customerService’.


Spring is nothing new. J2EE already provides similar functionality. Spring is a framework making use of J2EE componenets to make webdevelopment easier for developer.
Previously struts was there but it was only helping user with web components, spring helps users with all components of Application development - DB connectivity, making testing easier,
enabling easier way of implementing MVC, helping in business log etc.
Application Classes-> Spring Classes -> J2EE components
Spring is lightweight. Following are aspects of spring architecture.
1. Spring core
2. Spring AOP
3. Spring MVC
4. Spring Web
5. Spring ORM
6. Spring Context
7. Spring DAO
All the above components are loosely coupled, meaning if user wants to use only Spring MVC he doesn't need to learn other aspects.This is what light weight means.
A bean can be given init and destroy methods(need to mentioned in beans.xml)
RegisterShutDownhook can be called on ApplicationContext -> This will destroy all beans after end of main method
There are 3 ways of writing init and destroy for beans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Write methods in bean class-> mention their name in bean.xml
2. Annotate the methods with @PostConstruct, @PreDestroy and mention an annotation scnanner(CommonAnnotationBeanPostProcessor) bean in bean.xml
3. Implement 2 spring interfaces IntializingBean,DisposableBean
Writing pre-init and post-init methods for bean :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. pre-init and post-init functionality using BeanPostProcessor-> implement this and mention beanPostprocessor name in beans.xml
2. If you have multiple beanpostprocessor classes, also implement Ordered interface and return desired order number in getOrder method
Want to modify bean property before bean creation:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Impement BeanFactoryPostProcessor and do needful in postProcessesBeanFactory method and mention the bean in beans.xml
2. Spring provides builtIn implementations of BeanFactoryPostProcessor, like PropertyPlaceHolderConfigurator
	To use this :
	~~~~~~~~~~~~
	In beans.xml we can provide placeholder like ${WelcomeNote}... created spring.properties and mention key-value pair there.. Also mention PropertyPlaceHolderConfigurator bean
	and also classpath to properties file
	# This is very useful as this enabled user to change bean data using property files, Different files for PROD,UAT etc

#########################################################################################
Spring MVC:
##########################################################################################

Model - Data 
View - UI Response
Controller - Handler of request

Following is the work flow for a request:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Request<------->[Front Controller]
				<-----------> [Handler Mapping]
				<-----------> [Controller]
				<-----------> [View Resolver]
				<-----------> [View]
[Handler Mapping] -> Based on URL guides front controller on which controller to called
[Controller] -> Creates Model object and name of view to used to display
[View Resolver] -> Guides Front Controller in resolving info related to View
[View] -> A JSP page that has gift-wrapped the data(model) sent by controller.
[Front Controller] -> This is DispatcherServlet that returns a View to user upon getting request

Steps to create Sample Spring MVC Application:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Mention Dispatcherservlet for '/' in web.xml
#####################
WITHOUT ANNOTATIONS
####################
1. Create controller class extending AbstractController that returns a ModelAndView object
2. Create view page Hello.jsp
3. Create file spring-dispatcher-servlet.xml 
	-> Mention bean for HandlerMapping - BeanNameUrlHandlerMapping 
	-> Mention controller bean with url pattern as name
	-> Mention ViewResolver bean (InternalViewResolver)- This contains prefix(/Web-INF/jsp),suffix(.jsp) for view 
#################
WITH ANNOTATIONS
#################
1. Create controller class returns a method that returns ModelAndView object. Add @Controller annotation and for method @RequestMapping("/Welcome")
2. Create view page Hello.jsp
3. Create file spring-dispatcher-servlet.xml 
	-> Mention ViewResolver bean (InternalViewResolver)- This contains prefix(/Web-INF/jsp),suffix(.jsp) for view 
	-> Mention component-scan node for Scanning of annotations
	<context:component-scan base-package="com.amulya.spring" />
	
MultiActionControllerClass: 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If a controller has more than 1 requestmapping

Controller :
@Controller
@RequestMapping("/greet")

Method : 
@RequestMapping("/Welcome")
User : <hostName>/<WebAppName>/greet/Welcome

Something in URL changes everytime
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@RequestMapping("/greet/Welcome/{username}")

Want to access a placeholder for URL 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Add argument : (@PathVariable("username") String name)
Usage : System.out.println("Hello "+name)

MultiplePathVariables ????
~~~~~~~~~~~~~~~~~~~~~~~~~~
Add argument : (@PathVariable Map<String,String> pathVars)
Spring-dispatcher-servlet.xml : Mention <mvc:annotation-driven/>
Usage : System.out.println("Hello "+pathVars.get("username")+" from "+pathVars.get("countryname"))
Want to handle POST requests :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@RequestMapping(Value="/Welcome" method=RequestMethod.GET)

Want to read variables in request :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-> Assume case where html page is using action as "POST" and has 2 text fields
In argument : @RequestParam("username") String name
-> Want to assign default value to variables in request
In argument : 	@RequestParam(value="username" defaultValue="DummyUser") String username
-> Have multiple requestParams ?
In argument : @RequestParam Map<String,String> requestVars

Code to createModelAndView object:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In Controller :
ModelAndView object = new ModelAndView(<ViewName>);
object.setObject("WelcomeMessage","Hello Welcome");
return object;
In <ViewName>.jsp
<h1>${WelcomeMessage}</h1>

Want to include a bean in the View :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In Controller :
Student student = new Student();
student.setName("NewUser");
ModelAndView object = new ModelAndView(<ViewName>)
object.setObject("student",student);
In View :
<h1>${student.name}</h1>

Usage of @ModelAttribute :
~~~~~~~~~~~~~~~~~~~~~~~~~~~
In this approach, spring creates a bean with request params as ModelAttribute. Attributes of bean must have same name as requestParams
In Method Argument :
@ModelAttribute("student") Student student
In Controller :
ModelAndView object = new ModelAndView(<ViewName>)
object.setObject("hello","sfkjffds");
-> No need to set modelattribute manually to ModelAndView object
View :
<h1>${student.name}</h1>


When common attributes are to be added in Each ModelAndView object :
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In controller:

@ModelAttribute
public void addCommonObjectToAllViewsOfController(Model model)
{
model.add("watermark","All rights to this page are reserved")
}
-> This method gets called before RequestMapping gets resolved, all views will have access to this object now.
