It makes use of annotation-driven spring framework.
New KeyWords :
1. ContentNegotiatingViewResolver
2. BaseEntityInterceptor
3. TransactionInterceptor
4. Spring Security
5. AnnotationSessionFactoryBean

#######################
BaseEntityInterceptor 
#######################
->Found reference to this under AnnotationSessionFactoryBean bean mentioned in applicationContext.xml
->It is an implementation of a 'HibernateInterceptor' - had logic to update created_timestamp, lastUpdateTimestamp - logic common to 
all entities.
~~~~~~~~~~~~~~~~~~~~~~
Hibernate Interceptor
~~~~~~~~~~~~~~~~~~~~~~~
The Hibernate Interceptor is an interface that allows us to react to certain events within Hibernate.
There are two ways of defining interceptors:
  ->implementing the org.hibernate.Interceptor interface
  ->extending the org.hibernate.EmptyInterceptor class (Recommended)
How to write Hibernate Interceptor :
1. Create a class extending 'EmptyInterceptor'. 
2. Override required method say 'onsave()'.
  public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
  {
    Date date = new Date();
    if (((entity instanceof ServerJob)) || ((entity instanceof ServerJobHistory)) || ((entity instanceof ServerJobStatistics))) {
      date = DateUtils.getUTCTimeStamp();
    }
    setValue(state, propertyNames, this.createdUserID, AdminUtil.getLoggedInUserName());
    setValue(state, propertyNames, this.createdTimestamp, date);
    setValue(state, propertyNames, this.lastUpdatedUserID, AdminUtil.getLoggedInUserName());
    setValue(state, propertyNames, this.lastUpdatedTimestamp, date);
    return true;
  }
  
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Different methods available
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  onSave – Called when you save an object, the object is not save into database yet(Object Grid ??).
  onFlushDirty – Called when you update an object, the object is not update into database yet.
  onDelete – Called when you delete an object, the object is not delete into database yet.
  preFlush – Called before the saved, updated or deleted objects are committed to database (usually before postFlush).
  postFlush – Called after the saved, updated or deleted objects are committed to database.

 3. Register Hibernate interceptor either as Session-scoped or SessionFactory-scoped
  
 In Admin.war it was under bean 'AnnotationSessionFactoryBean' :
 <property name="entityInterceptor">
    		<bean class="com.kony.console.admin.domain.BaseEntityInterceptor"/>
 </property>

Session scoped or SessionFactory scoped ???
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A Session-scoped interceptor is linked to a specific session.
A SessionFactory-scoped interceptor is registered before building a SessionFactory
It’s important to note that a SessionFactory-scoped interceptor will be applied to all sessions. Hence, we need to be careful not to store session specific state – as this interceptor will be used by different sessions concurrently.For SessionFactory-scoped interceptors, we naturally need to ensure that it’s thread-safe.

#################################################################
Spring Security - provides security services to J2EE applications
#################################################################
Provides support for authentication by different ways – in-memory, DAO, JDBC, LDAP and many more.

Security has 2 aspects
-> Authentication - Check if user is valid - Verfies user info against specified creds using PasswordEncryptionAlgorithms
-> Authorization - Check if valid user has permission access - Based on user roles





